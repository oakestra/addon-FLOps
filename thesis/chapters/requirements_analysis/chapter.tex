\chapter{Requirements Analysis}

This chapter performs requirements engineering.
It uses the problem statement \ref{section:problem_statement}, objectives \ref{section:objectives}, and weaknesses found in the FL field \ref{subsection:fl_research} as input to elicit requirements.
These requirements are specified, analyzed, and concretized. 
This chapter starts by analyzing and deriving functional and nonfunctional requirements.
It utilizes (UML) models and use cases to explain the proposed system's functionalities and structure.
Its goal is to explain the new system's workflows, processes, and structural relationships without delving into concrete ways of realizing these goals.
This chapter focuses on the application domain, which represents the proposed system and its surrounding environment.
It is crucial to understand the basic behavior, reasoning, and environment of the system before working out how to realize these goals in a concrete manner.
The contributions section \ref{section:contributions} provides an overview of FLOps's functionalities and features and how they realize the discussed objectives.
This chapter follows the Requirements Analysis Document Template by Brügge et al. \cite{book:bruegge}.

\section{Proposed System}

\subsection{Functional Requirements}
Functional Requirements (FR) describe mandatory functional relationships between the proposed system and its surroundings.
These requirements only focus on concrete functionalities, user interactions, and environmental conditions.
They ignore implementation details and nonfunctional conditions, such as performance.
FRs capture what a proposed system must achieve instead of how it achieves it. \cite{book:bruegge}

\begin{itemize}
    \item [FR-1] {\textbf{Federated Learning}}
        \begin{itemize}
        \item [FR-1.1] \textbf{Enable individuals to use, develop, and evaluate practical FL}:
            FLOps is a platform where individuals can utilize FL regardless of their level of expertise.
            Target groups include inexperienced and expert users, developers, and researchers.
        \item [FR-1.2] \textbf{Automate FL management \& processes}:
            FLOps automatically handles all necessary duties to perform FL for the user.
            These duties include providing, creating, (un)deploying, and removing FL components, such as learners and aggregator(s).
            FLOps starts and stops the training and evaluation processes.
        \item [FR-1.3] \textbf{Support various flexible FL scenarios}:
            Besides classic FL, FLOps supports (clustered) HFL.
            FLOps is ML library/framework agnostic, allowing different ML techniques, such as DNNs and classic ML.
        \end{itemize}
    \item [FR-2] {\textbf{Provide Flexible Configuration}}:
        FLOps supports different FL project configurations.
        For example, users can specify and request different resource requirements, such as the number of training rounds, FL algorithms, and the minimum number of learners.
    \item [FR-3] {\textbf{Handle FL augmentation and containerization}}:
        FLOps automatically converts user ML code into FL-capable container images that include all necessary dependencies to do FL.
        It stores these images internally and deploys them for training.
    \item [FR-4] {\textbf{Provide a GUI for monitoring, evaluation, and result management}}:
        FLOps provides a sophisticated GUI for monitoring, comparing, storing, exporting, sharing, and organizing training runs, metrics, and trained models.
        Users can access this GUI at any time.
        They can follow live training progress or inspect their previous results.
    \item [FR-5] {\textbf{Provide trained model access to users}}:
        FLOps enables users to access their trained models.
        FLOps can build container images that serve the trained models.
        Users can pull these images to use their trained models as they wish.
        Users can see and access their models via the GUI.
    \item [FR-6] {\textbf{Enable inference serving}}:
        FLOps can automatically build and deploy inference servers based on trained models.
        Users can send inference requests to their trained models directly after training on the same platform.
\end{itemize}

\subsection{Nonfunctional Requirements}
Nonfunctional Requirements (NFR) define how the proposed system should work.
NFRs include constraints that the system must fulfill.
The following NFRs are based on the established FURPS+ categories, as seen in [BD09].
These NFRs mainly represent groups of requirements instead of intricate individual requirements to reduce bloat.

\begin{itemize}
    \item [NFR-1] {\textbf{Usability}}:
        \begin{itemize}
        \item [NFR-1.1] \textbf{Streamline FL processes \& abstract away complexities}:
            FLOps should automate and streamline FL, MLOps, and orchestration processes.
            Thus, it should allow users without specific experience in these domains to perform FL and benefit from these technologies.
            Flops should save time for FL experts by automating away redundant manual tasks.
            Users should be able to participate and initiate FL projects by providing a link to their (non-FL) ML code.
        \item [NFR-1.2] \textbf{Accelerate FL development and evaluation}: 
            FLOps should provide ready-made, extendable, multi-platform components to automate development and evaluation workflows.  
            Its GUI should follow established conventions for usability.
            Upholding these conventions is essential to ensure intuitive information visualization and easy navigation.
            Its CLI should provide a clear and complete set of commands to interact with the system.
            Each key user functionality should have a corresponding command, such as creation, inspection, and termination.
            The CLI's monitoring capabilities should be comprehensive and close to real-time (less than 5 seconds delay) to provide users with timely information.
            The CLI should provide users with thorough, supportive instructions and help messages to improve onboarding and general use.
            It should be possible to start and stop FLOps FL projects with a single request each.
        \end{itemize}
    \item [NFR-2] {\textbf{Supportability}}:
        \begin{itemize}
        \item [NFR-2.1] {\textbf{Maintainability}}:
            FLOps should make extending and modifying it straightforward and comfortable to ensure long-time developers and occasional contributors can work on it efficiently.
            The target group should include FL researchers who might have little experience in writing high-quality code.
            Its codebase should follow industry best practices for readability and maintainability.
            Therefore, FLOps should uphold high-quality code standards and use state-of-the-art libraries and frameworks.
            FLOps should uphold these conventions by enforcing formatters, linters, and automatic CI pipelines for verification.
            Its system design should be modular and extensible, allowing for easy updates and additions of new features or integrations with other technologies.
        \item [NFR-2.2] {\textbf{Portability}}:
            The system should be compatible with various platforms, environments, and hardware architectures.
            It should support AMD devices, which are primarily used for development, and ARM devices, which are mainly used in edge devices.
            FLOps should integrate seamlessly with existing or future tools and frameworks.
        \end{itemize}
    \item [NFR-3] {\textbf{Performance}}:
        \begin{itemize}
        \item [NFR-3.1] {\textbf{Scalability}}:
            FLOps should handle dynamic workload increases without significant degradation in performance.
            It should be able to scale across different hardware and network conditions.
            FLOps should be able to support a large number of client devices and training rounds.
            It should be able to manage and orchestrate multiple FL tasks simultaneously.
        \item [NFR-3.2] {\textbf{Availability}}:
            FLOps should provide reliable FL training by implementing robust error handling and recovery mechanisms, ensuring that the system can recover gracefully from failures during training or deployment.
            FLOps should ensure high availability and fault tolerance during FL training and orchestration.
            It should handle errors gracefully and provide meaningful error messages.
        \item [NFR-3.3] {\textbf{Containerization}}:
            The automatically created containerized images should have all necessary dependencies for FL training.
            They should adhere to best practices for speed and lightness.
            These images should support multiple platforms.
            The system should create containerized images quickly and efficiently.
            These image-building processes should not burden the control plane or user resources to avoid bottlenecks.
        \end{itemize}
    \item [NFR-4] {\textbf{Security}}:
        The system should ensure secure communication between client devices and the central server.
        It should protect sensitive data during FL training and deployment.
        Otherwise, the entire premise of FL gets broken, and legal issues arise.
    \item [NFR-5] {\textbf{Constraints}}:
        \begin{itemize}
            \item [NFR-5.1] {\textbf{Packaging}}:
                FLOps' components should be able to run on different architectures, such as ARM and AMD.
                To maximize coverage and compliance the automatically build container images should be compatible with dominating technologies like Docker or containerd.
            \item [NFR-5.2] {\textbf{Implementation}}:
                FLOps should not implement all of its features and components from the ground up to avoid subpar quality.
                It should use and benefit from existing solutions and technologies.
            \item [NFR-5.2] {\textbf{Interface}}:
                FLOps should uphold SLAs and standard API endpoint conventions to interact with other systems and orchestrators, thus allowing for flexibility in deployment environments.
        \end{itemize}
\end{itemize}




\section{System Models}

% TODO paraphraze!
In this section, we will analyze the formulated requirements. We start with user stories, i.e. scenarios that describe the new system which implements the requested changes.
We continue by illustrating the structure and workflows of the new system by creating various UML models.
Finally, we take a look at the GUI that shows how the user will interact with the new system.

\subsection{Scenarios}

% TODO paraphraze!
The goal of scenarios is to enhance the understanding of the proposed system by looking at a concrete set of common use cases [BD09].
These scenarios are also written in natural language to further increase the comprehension of the planed end user experience while working with the new system.
Scenarios can also be used to build models. We differentiate between two kinds of scenarios.
Demo scenarios that illustrate the achieved use cases of the new system.
Visionary scenarios portrait an almost utopian experience that will not be realized by this thesis, but lay the foundation for future work.

\subsubsection{Visionary Scenario}
TODO
% Maybe split scenarios up by target group - enduser no experience - FL researcher - FL dev
\subsubsection{Demo Scenario A}

\subsubsection{Demo Scenario B}

\subsection{Use Case Model}
% TODO paraphraze!
UML Use Case diagrams are used to visualize the available system functions from the user perspective, i.e. they illustrate the previously described functional requirements [BD09].
They illustrate all use cases instead of a subset like the previously covered scenarios.

\subsection{Analysis Object Model}
\subsection{Dynamic Model}
