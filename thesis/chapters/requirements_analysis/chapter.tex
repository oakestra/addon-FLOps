\chapter{Requirements Analysis}

This chapter performs requirements engineering.
It uses the problem statement \ref{section:problem_statement}, objectives \ref{section:objectives}, and weaknesses found in the FL field \ref{subsection:fl_research} as input to elicit requirements.
These requirements are specified, analyzed, and concretized. 
This chapter starts by analyzing and deriving functional and nonfunctional requirements.
It utilizes (UML) models and use cases to explain the proposed system's functionalities and structure.
Its goal is to explain the new system's workflows, processes, and structural relationships without delving into concrete ways of realizing these goals.
This chapter focuses on the application domain, which represents the proposed system and its surrounding environment.
It is crucial to understand the basic behavior, reasoning, and environment of the system before working out how to realize these goals in a concrete manner.
The contributions section \ref{section:contributions} provides an overview of FLOps's functionalities and features and how they realize the discussed objectives.
This chapter follows the Requirements Analysis Document Template by Br√ºgge et al. \cite{book:bruegge}.

\section{Proposed System}

\input{chapters/requirements_analysis/subsections/functional_requirements.tex}

\input{chapters/requirements_analysis/subsections/nonfunctional_requirements.tex}

\section{System Models}

% TODO paraphraze!
In this section, we will analyze the formulated requirements. We start with user stories, i.e. scenarios that describe the new system which implements the requested changes.
We continue by illustrating the structure and workflows of the new system by creating various UML models.
Finally, we take a look at the GUI that shows how the user will interact with the new system.

\subsection{Scenarios}

% TODO paraphraze!
The goal of scenarios is to enhance the understanding of the proposed system by looking at a concrete set of common use cases [BD09].
These scenarios are also written in natural language to further increase the comprehension of the planed end user experience while working with the new system.
Scenarios can also be used to build models. We differentiate between two kinds of scenarios.
Demo scenarios that illustrate the achieved use cases of the new system.
Visionary scenarios portrait an almost utopian experience that will not be realized by this thesis, but lay the foundation for future work.

\subsubsection{Visionary Scenario}
TODO
% Maybe split scenarios up by target group - enduser no experience - FL researcher - FL dev
\subsubsection{Demo Scenario A}

\subsubsection{Demo Scenario B}

\subsection{Use Case Model}
% TODO paraphraze!

UML Use Case diagrams depict the system functions from the external user perspective.
It shows system functionalities that lead to visible results for the users.
The shown functions and use cases are based on the previously explored functional requirements.
Unlike scenarios Use Case diagrams depict all functionalities in a non-concrete and abstract way.

\begin{figure}[p]
    \begin{adjustwidth}{-0.1\paperwidth}{-0.1\paperwidth}
        \centering
        \includegraphics[width=0.9\paperwidth]{uml_use_case_diagram.png}
        \caption{UML Use Case Diagram}
        \label{fig:uml_use_case_diagram}
    \end{adjustwidth}
\end{figure}

Figure \ref{fig:uml_use_case_diagram} shows the Use Case diagram for FLOps.
The white use cases represent the functionalities the external users can directly trigger.
The grey use cases are internal system actions that are directly visible or lead to visible results for the users.
For example, the user knows that FLOps is performing FL training by inspecting different provided outlets.
FLOps tracks the training progress and results.
These logged artifacts become incrementally visible to the user who inspects the GUI.
Thus, the user knows that FLOps is currently performing FL training and logging.
This diagram shows how users can interact with FLOps.
Use cases inside the GUI boundary are directly accessible via the GUI, same goes for the API boundary.
Other tasks are executed and accessible via FLOps combined with its orchestrator.
Use cases that involve developing or modifying FLOps itself are not explicitly portrait, but implied.
The depicted User actor represents endusers of varying FL expertice.
This actor includes FL developers and researchers.
The core usecase is starting an FL project.
This activity kicks of a chain of events, such as building a FL enabled container image, creating and deploying the learners and aggregator(s), and performing the FL training.
During training FLOps tracks the model and system metrics, which the user can monitor and evaluate in the GUI.
After training the trained model can be containerized and deployed as an inference server.
The user can access this trained model and request inference from its inference server.



\subsection{Analysis Object Model}
% TODO Paraphraze!
To increase the understanding of the underlying structure of the proposed
system UML class diagrams are used to visualize the main components and
their relationships [BD09].

\subsection{Dynamic Model}
