\subsection{Flower}

This subsection provides an overview of our FL framework of choice, Flower,
and highlights important aspects we rely upon.
This open-source framework has a corresponding 2022 research paper \cite{paper:flower}.
Flower's first release (0.10.0) was published in November 2020,
and its first major release (1.0.0) was published in 2022 \cite{fl_framework:flower}.
One major target in Flower's paper was to narrow the gap between research and production,
by allowing researchers to run high performance FL simulations and rapidly transition
to tangible production environments all via the same tool.
Another focal point of the paper was scale and parallelization.

Flower supports all major operating systems, containerization, and ML libraries.
It aims to be easily customizable and extendable via a programming language and ML framework agnostic design.
Flower strives to offer all popular FL features, such as support for different data types and distributions,
pre-implemented popular FL algorithms, support for vertical and horizontal data splitting,
traditional ML tasks, like regression or clustering, DNNs, LLMs, and security mechanisms, like secure aggregation.
It enables the use of FL via CPUs or GPUs.
Flower supports various FL variants, including
PFL, edge computing, cross-silo, and cross-device.
Flower handles and implements core FL components but does not handle many other aspects, like deployment,
orchestration, dependency management, or containerization.
Flower offers a mature set of FL simulation techniques.
The default communication protocol is gRPC, which can be exchanged.

Users can easily change and add functionality to the framework by interacting with flexible abstractions and interfaces.
The heart of Flower is its strategy concept.
The aggregator uses this strategy to manage the FL processes.
A strategy contains all necessary configurations,
such as the FL algorithm to use, the minimum number of learners required for training or evaluation, and more.
Users can pick from more than 30 existing strategies \cite{flower:strategies} or extend from basic strategies and develop their own behavior.

Flower has a lot to offer, but it still has its limits.
It does not have native out-of-the-box support for model pruning,
advanced security/privacy techniques, CFL, HFL, MLOps, or orchestration.
Due to Flowers' flexible design users can implement their custom additions and strategies
based on the available basic Flower components and realize many of these features.

On top of that, Flower has a modern, user-friendly, growing ecosystem.
A dedicated sub-project called Flower Datasets \cite{flower:datasets} is part of this ecosystem.
This project is still in its infancy (v0.3.0).
It allows users to pull HuggingFace \cite{hugging_face_homepage} datasets easily and split them into FL-optimized data fragments.
Users can configure how to split this data up.
In that way, Flower Datasets allows to use common non-federated homogeneous/IID datasets
to be turned into challenging, federated, non-IID data, ideal for FL research and development.
This ecosystem includes a well-structured and rich homepage \cite{flower:homepage}, an extensive set of tutorials, guides,
example projects \cite{flower:examples}, and documentation \cite{flower:homepage_docs, flower_docs} that ranges from beginner-friendly to advanced.
The Flower team has a solid and growing connection to the public and its user base.
They have open monthly community events \cite{flower:monthly}, yearly summits \cite{flower:summit}, a blog \cite{flower:blog}, a dedicated discussion forum \cite{flower:forum},
a Slack space \cite{flower:slack}, and a YouTube channel \cite{flower:youtube}.

It is straightforward to set up Flower and start working with it.
Flower is directly available via Python's default package manager pip.
One has to define the server/aggregator, strategy, and clients/learners.
Users can implement the simplest case with a few dozen lines of Python code.
The crucial part is to configure the strategy and clients properly.
One needs to create a client class that extends from a Flower client and implement four essential methods
that the framework will call during training.
These methods include a getter and setter for the model parameters and one method each for 
training/fitting and evaluating the model.