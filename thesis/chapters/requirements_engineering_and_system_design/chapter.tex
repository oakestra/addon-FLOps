\chapter{Requirements Engineering \& System Design}

\section{Requirements Elicitation \& Specification}

\input{chapters/requirements_engineering_and_system_design/subsections/functional_requirements.tex}
\input{chapters/requirements_engineering_and_system_design/subsections/nonfunctional_requirements.tex}


% #######################################

\section{Requirements Analysis}

This chapter performs requirements engineering.
It uses the problem statement \ref{section:problem_statement}, objectives \ref{section:objectives}, and weaknesses found in the FL field \ref{subsection:fl_research} as input to elicit requirements.
These requirements are specified, analyzed, and concretized. 
This chapter starts by analyzing and deriving functional and nonfunctional requirements.
It utilizes (UML) models and use cases to explain the proposed system's functionalities and structure.
Its goal is to explain the new system's workflows, processes, and structural relationships without delving into concrete ways of realizing these goals.
This chapter focuses on the application domain, which represents the proposed system and its surrounding environment.
It is crucial to understand the basic behavior, reasoning, and environment of the system before working out how to realize these goals in a concrete manner.
The contributions section \ref{section:contributions} provides an overview of FLOps's functionalities and features and how they realize the discussed objectives.
This chapter follows the Requirements Analysis Document Template by BrÃ¼gge et al. \cite{book:bruegge}.


\section{System Models}

After eliciting and specifying requirements, this section presents scenarios and analysis models representing how the system satisfies these requirements.
These models aim to improve the comprehension of FLOps on the application level instead of the solution one.
The models do not depict concrete implementation.
Instead, they show a simplified conceptual representation of FLOps' architecture and workflows.
This includes involved components and their relationships.
These are not identical to the actual implementation.
The goal is to improve comprehension of the system instead of showing overwhelmingly verbose intricate details that might change in future updates.

System models aim to build what is called an analysis model.
The analysis model has three distinct parts
The scenarios and use cases form the functional model.
Class and object models make the analysis object model.
State machines and sequence diagrams create the dynamic model of the system.  \cite{book:bruegge}

\input{chapters/requirements_engineering_and_system_design/subsections/scenarios.tex}

\input{chapters/requirements_engineering_and_system_design/subsections/use_case_diagram.tex}

\input{chapters/requirements_engineering_and_system_design/subsections/flops_overview.tex}

\input{chapters/requirements_engineering_and_system_design/subsections/analysis_object_models.tex}

\input{chapters/requirements_engineering_and_system_design/subsections/dynamic_models.tex}

% maybe combine both? -> but due to complexity and limited space - better to keep seperate
% components can show fine granined interactions in different deployments, e.g. how do the FLOps management components interact
% or how do the deployed FLOps services interacts on the different worker nodes
\subsection{Component Diagram}
% maybe even redundant if the component one is already clear enough.
% shows a more abstracted picture where stuff is deployed and the interactions between orchestrator - management - and workers
\subsection{Deployment Diagram}

% NOPE:(maybe also include explicit data management section - how d) -> place this in implementation section and go verbose